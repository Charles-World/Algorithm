//通过了g++编译，用的是c++0x标准
#include <iostream>
#define SZ 10
using namespace std;
//钢条切割问题的解决方法，是动态规划，先分析如何切割钢条，比如有n英寸的钢条需要切割
//那么，首先我们可以分析到它的子问题是:0英寸的钢条如何切,1英寸钢条如何切，……，n英寸钢条如何切
//这时我们会发现，这些子问题，在解决时会有它们各自的子子问题，并且这些子子问题是有重叠的
//比如切0英寸时，我们会发现不用切，直接为0，就是它的最大利润
//切1英寸时，也就一种方式，切1段，也相当于不用切，直接1段的利润就是它的最大利润
//切2英寸时，先切1英寸，然后再加上剩下部分所能获得的最大利润，也就是1英寸的利润加上1英寸的利润
//然后我可以直接切2英寸，加上剩下部分所能获得的最大利润，也就是2+0，这样就算完了2英寸切的所有方法
//然后从中选择一个利润最大的方式，保存下来，它就是切2英寸钢条所能获得的最大利润
//切3英寸时，先切1英寸，然后加上剩下部分所能获得的最大利润，也就是1加上2（这个2不是切2英寸，而
//是2英寸钢条所能获得的最大利润，这个在切2英寸时我们就算出来了）
//然后再尝试一次切2英寸，然后再加上剩下部分所能获得的最大利润，也就是2+1
//然后再尝试一次切3英寸，然后再加上剩下部分所能获得的最大利润，也就是3+0
//这样影响每次结果的都只是我们确定的长度，只要从中选择出利润最大的那一次切法
//就得出了本次切割的最大利润
//……
//而且我们可以发现每次在切割时，n英寸的钢条总是要用到比它小的钢条的切割利润
//而n-1总是要用到比它还小的钢条的切割利润，所以它们的子问题重叠了，我们只需要将
//比它们小的钢条算出来的利润，保存下来，那么在求解这些长度大的钢条时，就可以直接拿来用
//而且这个问题也有它的最优子结构，因为n英寸钢条的最优解是要用到比它更小的子结构的最优解的
//所以n英寸钢条的最优解包含着其子问题的最优解，所以这个问题是一个典型的动态规划算法
//而且只要我们申请一个空间，就可以在计算最优算的同时,找到一个最优解的描述方法,也就是
//获得的最优解是如何进行切割的
int Max(int a, int b, int *p)
{
	if(a < b)
	{
		*p = 1;
		return b;
	}
	else
	{
		return a;
	}

}
//自顶向下的备忘录模式
int CutRod(int *p, int n, int *r, int *s)
{
	if(r[n] >= 0)    //r就是我们的备忘录，里面存储着每英寸钢条可以获得的最大利润
	{
		return r[n]; //我们在构建这个备忘录时，是从无开始的，也就是说
					 //只要之前我们计算过这个n英寸钢条的利润，那么我们这个备忘录里就有
					 //那么它的利润一定是>=0的，因为最少就是没有，也就是0英寸钢条的利润
					 //如果小于0，那么就说明我们之前没有计算过这个英寸的利润，当然也就不能返回了
	}
	int money = -1;  //它是用来临时保存每英寸钢条的最大利润
	int *method = new int; //它是用来临时保存，每英寸钢条要想获得最大利润一次最多可分割多长
	*method = 0;
	if(n == 0)      //如果现在要计算的钢条长度为0，那么它的利润肯定是0
					//所以当我们要计算0英寸钢条时，可以直接给0
	{
		money = 0;
	}

	for(int i = 1; i <= n; ++i) //这里的1到n处理的是子子问题
	{
		if(i <= SZ)             //这里表示，如果要进行切割的钢条不大于SZ，也就是最高能切割的长度
				                //因为在开始的时候p数组就已经规定了最高一次切割多长
		                        //那么就将此长度进行切割后，所能获得的最大利润记录下来

		{
			money = Max(money, p[i-1] + CutRod(p, n-i, r, s), method);
			//首先，CutRod(p, n-i, r, s)它是处理子问题的，也就是说第一次运行到这时
			//表示的是对于长度是n的钢条，所以能获得的最大利润是多少
			//但是这时我们不能计算长度是n的钢条利润，所以进行递规
			//直到n=0时，也就是计算长度为0的钢条，所以能获得的最大长度
			//因为我们已经知道，它肯定为0，所以最多递规到这一层，就会返回
	        //它的子问题是先计算1英寸的钢条要如何切，再计算2英寸……直到最后可以计算英寸
			//所以每次递规，前面的n值都会变，每次递规都会进入for循环，但每次处理的问题不同
			//然后每次处理子子问题时，都是先尝试切割1，然后再加上n-i长度所能获得的最大的利润
			//每次计算完子子问题后，和前面尝试的值比较一下，如果这次比前面所获得的最大利润还大
			//那么就把这次的值设置为最大利润
			//直到最后一次切割n长度，再加0，就相当于遍历了一遍所有的方法
			//就得出了本次子问题的解了
			//传入method，是为了利用指针得到到底是原来的利润大，还是这次的利润大
			if(*method == 1) //如果是这次的利润大，那么就记录一下本次所切割的长度
			{
				*method = i;
			}
		}
		else      //如果一次切割长度超过最大长度，那么就不能继续切割更大的了
		{
			money = Max(money, p[SZ-1] + CutRod(p, n-i + (i-SZ), r, s), method);	
			//所以当超过这个长度，最大切割长度就固定了
			//那么后面加的最有利润，就是用本次的总长度
			//减去这次尝试的最大长度，因为我们在切割时
			//并未使用这次尝试的最大长度，所以后续计算
			//剩下钢条所能获得的最大利润时，就得多加上
			//几段，因为我们多减了(j-SZ)段，所以得加上
			if(*method == 1)
			{
				*method = i;
			}
		}
	}

	s[n] = *method;  //它是用来保存，每英寸钢条，要想获得最大利润，一次最多能切割多长
	r[n] = money;    //它是用来保存，每英寸钢条所能获得的最大利润
	return money;
}

//自底向上
void CutRod2(int *p, int n, int *r, int *s)
{
	int money = -1; //它是用来临时存储每英寸钢条，所能获得的最大利润
	r[0] = 0;		//它是真正用来存储每英寸钢条，所能获得的最大利润
					//r[0]表示0英寸的，r[1]表示1英寸的

	for(int i = 1; i <= n; ++i)     //这里1英寸开始计算，直到最后就可以计算n英寸的钢条了
	                                //这里的1到n，表示的是钢条切割问题的子问题
	                                //表示的是先计算1英寸的钢条要如何切，再计算2英寸……直到最后可以计算英寸
	{
		money = -1;                   //先置-1，表示还没有计算
		for(int j = 1; j <= i; ++j)   //这层循环是用来，处理子子问题的切割问题的
									  //根据第一层循环，可以看出有n个子问题，而这些子问题也有它们的子问题
									  //就是如果切割它们这些子问题
		{
			if(j <= SZ)               //这里表示，如果要进行切割的钢条不大于SZ，也就是最高能切割的长度
				                      //因为在开始的时候p数组就已经规定了最高一次切割多长
		                              //那么就将此长度进行切割后，所能获得的最大利润记录下来
			{
				if(money < p[j - 1] + r[i - j])   //这里p[j-1]表示，每英寸钢条所能获得的最大利润
					                              //因为p数组是从0个开始表示1英寸钢条的，所以-1
		                                          //r[i-j]表示，因为j表示的是本次所能切割的最大长度
						                          //所以用本次总长度i减去j，表示剩下的长度
			                                      //因为r存储的是每英寸的最大利润，所以加上最大利润
					                              //因为这层循环的j是从1到i循环的，所以就相当于从
                                                  //1到i开始切割，每次循环都相当于是尝试，看到底一次
							                      //切割多长，才是最优的利润，因为每次尝试的时候
				{	
					money = p[j - 1] + r[i - j];  //如果是的话，那么就将这个值保存下来
					s[i] = j;                     //如果这次最有的切割长度是使利润最大的长度，那么将它记录下来
				}
			}
			else                                  //如果切割长度超过最大长度，那么就不能继续切割更大的了
			{
				if(money < p[SZ - 1] + r[(i - j) + (j - SZ)])  //所以当超过这个长度，最大切割长度就固定了
								                               //那么后面加的最有利润，就是用本次的总长度
				                                               //减去这次尝试的最大长度，因为我们在切割时
			                                                   //并未使用这次尝试的最大长度，所以后续计算
			                                                   //剩下钢条所能获得的最大利润时，就得多加上
		                                                       //几段，因为我们多减了(j-SZ)段，所以得加上

				{
					money = p[SZ - 1] + r[(i - j)+ (j - SZ)];
					s[i] = j;
				}
			}

		}
		r[i] = money; //当一个子问题被解决时，记录下这个子问题的最优解
	}

}

void PrintCutRod(int *p, int n, int *r, int *s)
{
	CutRod2(p, n, r, s);//采用自底而上的计算方法
	//CutRod(p, n, r, s);
	cout << "最优价格为：" << r[n] << endl;
	cout << "最优策略为：";
	while(n > 0) //因为s存储的是每英寸钢条，如果想要获得最大利润，最大可以切割的长度
				 //n表示总长度，所以用n减去最大可以切割的长度，就可以得到剩下的长度
				 //然后再进行比较看能切割的长度是多少，相减如果不等于0，那么就继续
				 //直到能切割的长度为0，就得到了切割的方法
	{
		cout << s[n] << " ";
		n = n - s[n];
	}
	cout << endl;
}

int main()
{
	int p[] = {1, 5, 8, 9, 10, 17, 19, 20, 24, 30}; //p表示每英寸钢条所能获得的收益，1英寸对应1，2英寸对应5
	cout << "钢条价格表：1, 5, 8, 9, 10, 17, 19, 20, 24, 30" << endl << "请输入要计算的钢条长度:" << endl;
	int n = 0;
	cin >> n;    //获取要进行切割的钢条长度
	int r[n+1];  //用来保存每英寸钢条，所能获得的最大利润，n+1是因为会保存0英寸的利润，所以多了一个元素
	for(int i = 0; i < n + 1; ++i)
	{
		r[i] = -1;
	}
	int s[n+1];  //用来保存每黄壤钢条，要想获得最大利润，一次最多切割多长
	
	PrintCutRod(p, n, r, s);


	return 0;
}
